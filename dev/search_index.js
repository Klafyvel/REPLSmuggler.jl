var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = REPLSmuggler","category":"page"},{"location":"#REPLSmuggler","page":"Home","title":"REPLSmuggler","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for REPLSmuggler.","category":"page"},{"location":"","page":"Home","title":"Home","text":"REPLSmuggler is meant to evaluate code coming from various clients in your REPL. The main goal is for an editor to send a bunch of lines of code with some metadata giving the name of the file and the line. REPLSmuggler will evaluate the code and send back the return value. If an error is raised, it will send the traceback to the client.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the the companion plugin for NeoVim.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depth=5","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using REPLSmuggler is as simple as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using REPLSmugglers\njulia> smuggle()\n[ Info: Ahoy, now smuggling from socket /run/user/1000/julia/replsmuggler/contraband_clandestine_operation.\nTask (runnable) @0x0000753a784c6bd0","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are then able to send code and get notified when an error happens.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At any point you can show the current smuggler by calling showsmuggler() in the REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"smuggle can also be used the other way around, to directly send diagnostics to your editor. For example, if your editor has smuggled the following function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function bad_bad_bad()\n  error(\"hey!\")\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can send back diagnostics to the editor directly from the REPL by catching  an exception.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> try\n       bad_bad_bad()\ncatch exc\n       smuggle(exc)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can even send directly diagnostics, without looking for code that has actually been sent by the editor:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> smuggle(\"hey\", \"foo\", \"$(pwd())/test.jl\", 11, \"none\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"There's also an extension to work with JET's  reports. Say you smuggled the following functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function foo(s0)\n  a = []\n  for s in split(s0)\n    push!(a, bar(s))\n  end\n  return sum(a)\nend\nbar(s::String) = parse(Int, s)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can smuggle back to the editor JET's report as follow:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> smuggle(@report_call foo(\"1 2 3\"))","category":"page"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"#REPLSmuggler-2","page":"Home","title":"REPLSmuggler","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [REPLSmuggler]","category":"page"},{"location":"#REPLSmuggler.CURRENT_SMUGGLER","page":"Home","title":"REPLSmuggler.CURRENT_SMUGGLER","text":"Store the current server.\n\n\n\n\n\n","category":"constant"},{"location":"#REPLSmuggler.basepath-Tuple{}","page":"Home","title":"REPLSmuggler.basepath","text":"basepath()\n\nReturn a path where REPLSmuggler can store its socket, depending on the OS.\n\nFor Linux: /run/user/<uid>/julia/replsmuggler/\nFor Windows: \\\\.\\pipe\\\nFor MacOS: ~/Library/Application Support/julia/replsmuggler/\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.showsmuggler-Tuple{}","page":"Home","title":"REPLSmuggler.showsmuggler","text":"Print the current smuggler path\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.smuggle-NTuple{5, Any}","page":"Home","title":"REPLSmuggler.smuggle","text":"smuggle(title, diagnostic, filename, line, function)\n\nSmuggle a diagnostic in file filename, function function, at line line.\n\nwarning: Warning\nThe notification will be sent to all connected sessions.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.smuggle-Tuple{AbstractString}","page":"Home","title":"REPLSmuggler.smuggle","text":"smuggle([name]; basepath=basepath(), serializer=MsgPack)\n\nStart a server using a UNIX sockets with a random name and MsgPack.jl as a serializer. The socket will be stored in joinpath(basepath, name). If name is not provided, REPLSmuggler will try randomly generated names until a  non-already-existing socket name is found.\n\nFor example, on linux, you could find the socket in /run/user/1000/julia/replsmuggler/clandestine_underworld if the name was chosen to be clandestine_underworld.\n\nThe socket name is displayed in the REPL, and the server is accessible through CURRENT_SMUGGLER.\n\nSee also basepath.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.smuggle-Tuple{Base.ExceptionStack}","page":"Home","title":"REPLSmuggler.smuggle","text":"smuggle(stacks::Base.ExceptionStack)\n\nSmuggle an exception stack. In the Julia REPL the err variable is implicitly defined and contains the stack from the last thrown error.\n\nExamples\n\njulia> error(\"foo\")\nERROR: foo\nStacktrace:\n[...]\n\njulia> smuggle(err)\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.smuggle-Union{Tuple{T}, Tuple{T, Any}} where T<:Exception","page":"Home","title":"REPLSmuggler.smuggle","text":"smuggle(exception, stackframes=stacktrace(Base.catch_stacktrace()))\n\nSmuggle an exception. Can be used to report on exceptions thrown by code evaluated by the user in the REPL.\n\nwarning: Warning\nThe notification will be sent to all connected sessions.\n\nExamples\n\ntry\n    error(\"foo\")\ncatch exc\n    smuggle(exc)\nend\n\n\n\n\n\n","category":"method"},{"location":"#Protocol","page":"Home","title":"Protocol","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [REPLSmuggler.Protocols]","category":"page"},{"location":"#REPLSmuggler.Protocols","page":"Home","title":"REPLSmuggler.Protocols","text":"Definition of the protocol used by REPLSmuggler.jl. It is based on MsgPack-RPC, see here:\n\nhttps://github.com/msgpack/msgpack/blob/master/spec.md\nhttps://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md\n\nThe actual (de)serialization from and to MsgPack objects is handled by MsgPack.jl through a lightweight wrapper defined in MsgPackSerializer.\n\nThe protocol consists of requests messages and their corresponding response messages. There can also be notification messages.\n\nAs per the specification, a request is serialized to an array of four elements, that could be written in Julia as follow:\n\n[type::UInt8, msgid::UInt32, method::String, params::Vector{Any}]\n\nWhere type = 0x00. For convenience, we define a structure and teach MsgPack.jl to serialize it.\n\nA response message should be serialized as:\n\n[type::UInt8, msgid::UInt32, error::Any, result::Any]\n\nWhere type = 0x01. msgid is the identifier of the corresponding request.\n\nFinally, a notification has the form:\n\n[type::UInt8, method::String, params::Vector{Any}]\n\nWhere type = 0x02.\n\nDefined methods for requests.\n\nWe allow the client to run the following methods. If a method is unknown by the server, it will raise an error.\n\neval: Evaluate a chunk of code. Parameters:\nfile::String\nline::UInt32\ncode::String\nconfigure: Configure the current session. Parameters:\nsettings::Dict{String, Any}\nSettings do not have to be given in the request if you are not changing them.  Currently, the following settings are supported:\nevalbyblocks::Bool should the session evaluate entries by block rather than\nby toplevel statements?\ninterrupt: Interrupt the current evaluation. No parameter.\nexit: Stop the current session. No parameter.\n\nResponses of the server.\n\nThe result field is a string of what would be printed in the REPL. It is empty if an error occured. \n\nIf an error occured, then the error field is a three-elements array structured as follow:\n\nexception::String: Name of the exception, e.g. \"ValueError\",\nexception_text::String: Text, e.g. \"This value cannot be < 0.\",\nstacktrace::Vector{Tuple{String, UInt32, String}}: The stacktrace, with each  row being (file, line, function).\n\nNotifications by the server.\n\nCurrently, the following notifications can be sent by the server. If a notification received by the client is unknown, it should simply be ignored without erroring.\n\nhandshake: Sent at the begining of a session, mainly to ensure the correct version of the protocol is being used. Parameters:\nmyname::String: Name of the server. Will typically be REPLSmuggler, but could be replaced if other implementations of the protocol were to exist.\nversion::String: A sementic versioning version number telling the client which version of the protocol is being used by the server.\ndiagnostic: Sent following the evaluation of some code by the user from the   REPL. For example, this could be used via a direct call to display a diagnostic  on a specific line, or to report an exception from some code evaluated by the   user, or report diagnostic from other packages such as JET.jl. This is very  similar to how an exception would be handled when executing code.  Parameters:\ntitle::String: Short title for the diagnostic.\ndiagnostic::String: The diagnostic that is to be displayed.\nstacktrace::Vector{Tuple{String, UInt32, String}}: The stacktrace, with\neach row being (file, line, function).\n\nTypical session:\n\nThe client connects to the server.\nThe server sends a handshake notification.\nThe client checks it is running the correct version of the protocol.\nThe client runs requests (eval, interrupts...)\nThe server responds to the requests.\nThe client runs exit.\nThe server stops all the running code and close the session.\n\nNote that any interrupt of the connection (i.e. closing the socket) is equivalent to sending an exit request.\n\n\n\n\n\n","category":"module"},{"location":"#REPLSmuggler.Protocols.PROTOCOL_MAGIC","page":"Home","title":"REPLSmuggler.Protocols.PROTOCOL_MAGIC","text":"Name of the protocol implementation.\n\n\n\n\n\n","category":"constant"},{"location":"#REPLSmuggler.Protocols.PROTOCOL_VERSION","page":"Home","title":"REPLSmuggler.Protocols.PROTOCOL_VERSION","text":"Protocol version.\n\n\n\n\n\n","category":"constant"},{"location":"#REPLSmuggler.Protocols.AbstractMsgPackRPC","page":"Home","title":"REPLSmuggler.Protocols.AbstractMsgPackRPC","text":"Represents a MsgPackRPC message. type needs not to be stored explicitely.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.AbstractResponse","page":"Home","title":"REPLSmuggler.Protocols.AbstractResponse","text":"Represents a response.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.MsgType","page":"Home","title":"REPLSmuggler.Protocols.MsgType","text":"MsgPackRPC message types.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.Notification","page":"Home","title":"REPLSmuggler.Protocols.Notification","text":"Represents a notification.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.ProtocolException","page":"Home","title":"REPLSmuggler.Protocols.ProtocolException","text":"Used internally to report protocol exceptions.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.Request","page":"Home","title":"REPLSmuggler.Protocols.Request","text":"Represents a request.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.Diagnostic-Tuple{Any, Any, Any}","page":"Home","title":"REPLSmuggler.Protocols.Diagnostic","text":"Diagnostic(title, diagnostic, stackframe)\n\nSee protocol's definition and build stackframe accordingly.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.Error-Union{Tuple{T}, Tuple{Any, T, Any}} where T","page":"Home","title":"REPLSmuggler.Protocols.Error","text":"Error(msgid, error, stackframe)\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.Handshake-Tuple{}","page":"Home","title":"REPLSmuggler.Protocols.Handshake","text":"Handshake()\n\nCreate a hand-shake notification.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.Result-Tuple{Any, Any}","page":"Home","title":"REPLSmuggler.Protocols.Result","text":"Result(msgid, result)\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.astuple","page":"Home","title":"REPLSmuggler.Protocols.astuple","text":"astuple(message)\n\nReturns a vector from the message that can be serialized.\n\n\n\n\n\n","category":"function"},{"location":"#REPLSmuggler.Protocols.deserialize","page":"Home","title":"REPLSmuggler.Protocols.deserialize","text":"serialize(protocol)\n\nDe-serialize an AbstractMsgPackRPC. Must be implemented by the serializer, e.g. MsgPackSerializer.jl.\n\n\n\n\n\n","category":"function"},{"location":"#REPLSmuggler.Protocols.dispatchonmessage-Tuple{REPLSmuggler.Protocols.Protocol, Any, Vararg{Any}}","page":"Home","title":"REPLSmuggler.Protocols.dispatchonmessage","text":"dispatchonmessage(protocol, f, args...; kwargs)\n\nDeserialize a request, and send it to the correct method of f. f should define methods with a first parameter being of type Val{:method} where method can be: \"eval\", \"interrupt\", or \"exit\". f is called as:\n\nf(Val(method), args..., request.msgid, request.params...; kwargs...)\n\nA ProtocolException might be raised if the request is malformed.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.serialize","page":"Home","title":"REPLSmuggler.Protocols.serialize","text":"serialize(protocol, message)\n\nSerialize an AbstractMsgPackRPC. Must be implemented by the serializer, e.g. MsgPackSerializer.jl.\n\n\n\n\n\n","category":"function"},{"location":"#Server","page":"Home","title":"Server","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [REPLSmuggler.Server]","category":"page"},{"location":"#REPLSmuggler.Server","page":"Home","title":"REPLSmuggler.Server","text":"Implementation of the server for REPLSmuggler.jl -the brain of REPSmuggler.jl.\n\nThe handling of the communication protocol is done by Protocols.\n\nThe implementation is heavily inspired by the server from RemoteREPL.jl.\n\n\n\n\n\n","category":"module"},{"location":"#REPLSmuggler.Server.Session","page":"Home","title":"REPLSmuggler.Server.Session","text":"The session of a client.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Server.Smuggler","page":"Home","title":"REPLSmuggler.Server.Smuggler","text":"Store the sessions of a server.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Server.deserialize_requests-Tuple{REPLSmuggler.Server.Session, Any}","page":"Home","title":"REPLSmuggler.Server.deserialize_requests","text":"Dispatch repeatedly the incoming requests of a session.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.evaluate_entries-Tuple{Any}","page":"Home","title":"REPLSmuggler.Server.evaluate_entries","text":"evaluate_entries(session)\n\nRepeatedly evaluate the code put to the input channel of the session.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.evaluate_entry-NTuple{5, Any}","page":"Home","title":"REPLSmuggler.Server.evaluate_entry","text":"evaluate_entry(session, msgid, file, line, value)\n\nEvaluate the code in value in the context of the given session, replacing the context of the code with file and line. If an error occurs, it will put a  using Base: JuliaSyntax Protocols.Error to the outgoing channel of the session.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.getsession-Tuple{REPLSmuggler.Server.Smuggler}","page":"Home","title":"REPLSmuggler.Server.getsession","text":"getsession(smuggler)\n\nReturn a Session through a call to waitsession.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.serialize_responses-Tuple{Any}","page":"Home","title":"REPLSmuggler.Server.serialize_responses","text":"Send repeatedly the responses of a given session.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.serve_repl-Tuple{REPLSmuggler.Server.Smuggler}","page":"Home","title":"REPLSmuggler.Server.serve_repl","text":"Serve sessions to clients connecting to a server.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.serve_repl_session-Tuple{Any}","page":"Home","title":"REPLSmuggler.Server.serve_repl_session","text":"Serve one session, starting three loops to evaluate the entries, serialize the responses and deserialize the requests.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.sessions-Tuple{REPLSmuggler.Server.Smuggler}","page":"Home","title":"REPLSmuggler.Server.sessions","text":"Get the sessions.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.treatrequest","page":"Home","title":"REPLSmuggler.Server.treatrequest","text":"Fed to Protocols.dispatchonmessage to respond accordingly to incoming requests.\n\n\n\n\n\n","category":"function"},{"location":"#REPLSmuggler.Server.vessel-Tuple{REPLSmuggler.Server.Smuggler}","page":"Home","title":"REPLSmuggler.Server.vessel","text":"Get the vessel.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.waitsession-Tuple{T} where T","page":"Home","title":"REPLSmuggler.Server.waitsession","text":"Has to be implemented for each specific server. See for example SocketSmugglers.\n\nShould return the specific of a session used to build a Session.\n\n\n\n\n\n","category":"method"},{"location":"#Default-implementation","page":"Home","title":"Default implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [REPLSmuggler.MsgPackSerializer, REPLSmuggler.SocketSmugglers]","category":"page"},{"location":"#REPLSmuggler.MsgPackSerializer","page":"Home","title":"REPLSmuggler.MsgPackSerializer","text":"The default serializer for REPLSmuggler.jl\n\n\n\n\n\n","category":"module"},{"location":"#REPLSmuggler.SocketSmugglers","page":"Home","title":"REPLSmuggler.SocketSmugglers","text":"A specific kind of server for UNIX sockets / Windows pipes.\n\n\n\n\n\n","category":"module"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
